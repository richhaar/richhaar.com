"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[323],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),m=i,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||r;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1187:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},assets:function(){return c},toc:function(){return u},default:function(){return m}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),o=["components"],s={slug:"visitor-pattern-in-cpp17",title:"Using the Visitor pattern in C++17",authors:"rich",tags:["C++"]},l=void 0,p={permalink:"/visitor-pattern-in-cpp17",editUrl:"https://github.com/richhaar/richhaar.com/edit/main/blog/2021-09-26-visitor-pattern-in-cpp17.md",source:"@site/blog/2021-09-26-visitor-pattern-in-cpp17.md",title:"Using the Visitor pattern in C++17",description:"In C++17, the std::variant and how it fit's into the Visitor pattern.",date:"2021-09-26T00:00:00.000Z",formattedDate:"September 26, 2021",tags:[{label:"C++",permalink:"/tags/c"}],readingTime:3.11,truncated:!0,authors:[{name:"Richard Haar",title:"Computer Scientist",url:"https://github.com/richhaar",imageURL:"/img/profile2.png",key:"rich"}],prevItem:{title:"Multivariable linear regression in Python",permalink:"/multivariable-linear-regression"},nextItem:{title:"Making it to the front page on StackOverflow",permalink:"/stackoverflow"}},c={authorsImageUrls:[void 0]},u=[{value:"Basic Usage",id:"basic-usage",children:[]},{value:"A Shapes Example",id:"a-shapes-example",children:[{value:"When to use the Visitor pattern?",id:"when-to-use-the-visitor-pattern",children:[]},{value:"Comparison to polymorphism",id:"comparison-to-polymorphism",children:[]}]}],d={toc:u};function m(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In C++17, the ",(0,r.kt)("inlineCode",{parentName:"p"},"std::variant")," was introduced alongside the ",(0,r.kt)("inlineCode",{parentName:"p"},"std::visit")," function which allows you to implement the Visitor pattern rather easily. To begin with I'll explain how to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"std::variant")," and how it fit's into the Visitor pattern."),(0,r.kt)("h2",{id:"basic-usage"},"Basic Usage"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"std::variant")," is templated across multiple types, so that your variant can hold any one of those types. Have a look at the example below where the variant can hold either a ",(0,r.kt)("inlineCode",{parentName:"p"},"std::string")," or an ",(0,r.kt)("inlineCode",{parentName:"p"},"int"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="std::variant example usage"',title:'"std::variant',example:!0,'usage"':!0},'#include <variant>\n#include <iostream>\n\nint main()\n{\n    std::variant<int, std::string> myvariant = 0;\n\n    int const num = std::get<int>(myvariant);\n    std::cout << "My int is " << num << std::endl;\n\n    myvariant = "zero";\n\n    std::string const str = std::get<std::string>(myvariant);\n    std::cout << "My string is " << str << std::endl;\n\n    return 0;\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"My int is 0\nMy string is zero\n")),(0,r.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Calling ",(0,r.kt)("inlineCode",{parentName:"p"},"std::get")," with the wrong type will throw an error."))),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"Info")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Similar to how TypeScript defines the types allowed for a given variable, a std::variant allows the usage of multiple types."))),(0,r.kt)("h2",{id:"a-shapes-example"},"A Shapes Example"),(0,r.kt)("p",null,"Here is a slightly more involved example, where three shapes are defined, with no common base class. And a vector is defined holding any of the three shapes."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="A vector of variants"',title:'"A',vector:!0,of:!0,'variants"':!0},"#include <variant>\n#include <iostream>\n#include <vector>\n\nclass Circle\n{\n    double r_;\n    public:\n    Circle(int r) : r_(r) {};\n    double getRadius() const { return r_; }\n};\n\nclass Triangle\n{\n    double l_;\n    public:\n    Triangle(int l) : l_(l) {};\n    double getLength() const { return l_; }\n};\n\nclass Square\n{\n    double l_;\n    public:\n    Square(int l) : l_(l) {};\n    double getLength() const { return l_; }\n};\n\nusing Shape = std::variant<Circle, Triangle, Square>;\n\nint main()\n{\n    std::vector<Shape> shapes {\n        Triangle(3.0),\n        Square(4.0),\n        Circle(10.0)\n    };\n\n    return 0;\n}\n")),(0,r.kt)("p",null,"Now the visitor pattern is setup so that ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Visitor_pattern"},"to quote wikipedia"),":"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"It should be possible to define a new operation for (some) classes of an object structure without changing the classes.")),(0,r.kt)("p",null,"So here is where ",(0,r.kt)("inlineCode",{parentName:"p"},"std::visit")," comes into play, where an overloaded function can be applied to a ",(0,r.kt)("inlineCode",{parentName:"p"},"std::variant"),". So for example we could use a lambda or define a struct that has an ",(0,r.kt)("inlineCode",{parentName:"p"},"operator()")," defined for each type we need. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="Defining the function to apply to the variant"',title:'"Defining',the:!0,function:!0,to:!0,apply:!0,'variant"':!0},"#include <cmath>\n// ...\n// Previous shape code ommited\n// ...\nstruct CalculateArea\n{\n    double operator()(Square const& sq)\n    {\n        return std::pow(sq.getLength(), 2.0);\n    }\n\n    double operator()(Circle const& c)\n    {\n        return 3.14159265359 * std::pow(c.getRadius(), 2.0);\n    }\n\n    double operator()(Triangle const& t)\n    {\n        return (std::sqrt(3.0) / 4.0) * std::pow(t.getLength(), 2);\n    }\n};\n")),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"Info")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Triangle area is calculated based on an equilateral triangle"))),(0,r.kt)("p",null,"And we can apply the function by using ",(0,r.kt)("inlineCode",{parentName:"p"},"std::visit")," as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'    for(auto& shape : shapes)\n    {\n       std::cout << "Area: " << std::visit(CalculateArea(), shape) << std::endl;\n    }    \n')),(0,r.kt)("p",null,"Giving us our result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Area: 3.89711\nArea: 16\nArea: 314.159\n")),(0,r.kt)("h3",{id:"when-to-use-the-visitor-pattern"},"When to use the Visitor pattern?"),(0,r.kt)("p",null,"The Visitor pattern can be useful when you need to constantly add new operations to your set of types. For example, now it would be possible to add another function making use of the shape's size without affecting the previous code (e.g.  a function ",(0,r.kt)("inlineCode",{parentName:"p"},"ValidShape")," checking if the shape has a length or radius greater than zero). However adding new types may mean you have to revisit all your previous functions you have defined."),(0,r.kt)("h3",{id:"comparison-to-polymorphism"},"Comparison to polymorphism"),(0,r.kt)("p",null,"The typical Shape example consists of having a base class Shape which then has virtual functions such as ",(0,r.kt)("inlineCode",{parentName:"p"},"CalculateArea"),". Then each class would have to implement the virtual function if it was pure virtual. Whereas with the Visitor pattern you can add functions to given classes as needed."),(0,r.kt)("p",null,"For more examples see cppreference:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://en.cppreference.com/w/cpp/utility/variant/visit"},"std::visit")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://en.cppreference.com/w/cpp/utility/variant"},"std::variant"))))}m.isMDXComponent=!0}}]);